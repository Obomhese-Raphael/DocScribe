import Document from "../models/documentModel.js";

// Get all processed documents with summaries for the history page
export const getSummariesHistory = async (req, res) => {
  try {
    // Get all processed documents with summaries, sorted by upload date (newest first)
    const documents = await Document.find({});
    

    // Transform the data to match the frontend interface
    const summaries = documents.map((doc) => ({
      _id: doc._id,
      documentId: doc._id,
      summaryText: doc.summary,
      summaryDate: doc.uploadDate, // Using uploadDate as summaryDate since summary is generated after upload
      document: {
        _id: doc._id,
        originalName: doc.originalName,
        fileType: doc.fileType,
        uploadDate: doc.uploadDate,
        fileSize: doc.fileSize,
      },
    }));

    res.status(200).json({
      success: true,
      data: summaries,
      count: summaries.length,
    });
  } catch (error) {
    console.error("Error fetching summaries:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch document summaries",
    });
  }
};

// Download document summary as a text file
export const downloadSummary = async (req, res) => {
  try {
    const { id } = req.params;

    // Find the document by ID
    const document = await Document.findById(id);

    if (!document) {
      return res.status(404).json({
        success: false,
        error: "Document not found",
      });
    }

    if (!document.summary) {
      return res.status(404).json({
        success: false,
        error: "Summary not available for this document",
      });
    }

    // Create summary content with metadata
    const summaryContent = `
  Document Summary
  ================
  
  Original File: ${document.originalName}
  File Type: ${document.fileType}
  File Size: ${(document.fileSize / 1024).toFixed(2)} KB
  Upload Date: ${document.uploadDate.toLocaleString()}
  Processed: ${document.isProcessed ? "Yes" : "No"}
  
  Summary:
  --------
  ${document.summary}
  
  Generated by DocScribe
  Date: ${new Date().toLocaleString()}
      `.trim();

    // Set headers for file download
    res.setHeader("Content-Type", "text/plain");
    res.setHeader(
      "Content-Disposition",
      `attachment; filename="${
        document.originalName.split(".")[0]
      }-summary.txt"`
    );

    res.status(200).send(summaryContent);
  } catch (error) {
    console.error("Error downloading summary:", error);
    res.status(500).json({
      success: false,
      error: "Failed to download summary",
    });
  }
};

// Generate a shareable link for the document summary
export const generateShareLink = async (req, res) => {
  try {
    const { id } = req.params;

    // Find the document by ID
    const document = await Document.findById(id);

    if (!document) {
      return res.status(404).json({
        success: false,
        error: "Document not found",
      });
    }

    if (!document.summary) {
      return res.status(404).json({
        success: false,
        error: "Summary not available for this document",
      });
    }

    // Generate a shareable link (you can customize this based on your domain)
    const baseUrl =
      process.env.FRONTEND_URL || req.get("origin") || "http://localhost:3000";
    const shareableLink = `${baseUrl}/shared/${document._id}`;

    res.status(200).json({
      success: true,
      shareableLink: shareableLink,
    });
  } catch (error) {
    console.error("Error generating share link:", error);
    res.status(500).json({
      success: false,
      error: "Failed to generate share link",
    });
  }
};

// Delete a document and its summary
export const deleteDocument = async (req, res) => {
  try {
    const { id } = req.params;

    // Find and delete the document
    const document = await Document.findByIdAndDelete(id);

    if (!document) {
      return res.status(404).json({
        success: false,
        error: "Document not found",
      });
    }

    res.status(200).json({
      success: true,
      message: "Document and summary deleted successfully",
    });
  } catch (error) {
    console.error("Error deleting document:", error);
    res.status(500).json({
      success: false,
      error: "Failed to delete document",
    });
  }
};

// Get shared summary by document ID
export const getSharedSummary = async (req, res) => {
  try {
    const { id } = req.params;

    // Find the document by ID
    const document = await Document.findById(id).select(
      "originalName fileType uploadDate summary isProcessed fileSize"
    );

    if (!document) {
      return res.status(404).json({
        success: false,
        error: "Document not found",
      });
    }

    if (!document.summary || !document.isProcessed) {
      return res.status(404).json({
        success: false,
        error: "Summary not available for this document",
      });
    }

    // Return the shared summary data
    res.status(200).json({
      success: true,
      data: {
        _id: document._id,
        summaryText: document.summary,
        summaryDate: document.uploadDate,
        document: {
          _id: document._id,
          originalName: document.originalName,
          fileType: document.fileType,
          uploadDate: document.uploadDate,
          fileSize: document.fileSize,
        },
      },
    });
  } catch (error) {
    console.error("Error fetching shared summary:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch shared summary",
    });
  }
};

// Get all documents with pagination and search functionality
export const getAllDocuments = async (req, res) => {
  try {
    const { page = 1, limit = 10, search = "", processed } = req.query;

    // Build query
    let query = {};

    // Add search functionality
    if (search) {
      query.$or = [
        { originalName: { $regex: search, $options: "i" } },
        { summary: { $regex: search, $options: "i" } },
      ];
    }

    // Filter by processed status if specified
    if (processed !== undefined) {
      query.isProcessed = processed === "true";
    }

    // Execute query with pagination
    const documents = await Document.find(query)
      .sort({ uploadDate: -1 })
      .limit(limit * 1)
      .skip((page - 1) * limit)
      .select(
        "originalName fileName fileType fileSize uploadDate summary isProcessed"
      );

    // Get total count for pagination
    const total = await Document.countDocuments(query);

    res.status(200).json({
      success: true,
      data: documents,
      pagination: {
        current: page,
        pages: Math.ceil(total / limit),
        total,
      },
    });
  } catch (error) {
    console.error("Error fetching documents:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch documents",
    });
  }
};

// Get a specific document by ID
export const getDocumentById = async (req, res) => {
  try {
    const { id } = req.params;

    const document = await Document.findById(id);

    if (!document) {
      return res.status(404).json({
        success: false,
        error: "Document not found",
      });
    }

    res.status(200).json({
      success: true,
      data: document,
    });
  } catch (error) {
    console.error("Error fetching document:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch document",
    });
  }
};

// Update the summary of a document
export const updateDocumentSummary = async (req, res) => {
  try {
    const { id } = req.params;
    const { summary } = req.body;

    if (!summary) {
      return res.status(400).json({
        success: false,
        error: "Summary text is required",
      });
    }

    const document = await Document.findByIdAndUpdate(
      id,
      {
        summary: summary.trim(),
        isProcessed: true,
      },
      { new: true }
    );

    if (!document) {
      return res.status(404).json({
        success: false,
        error: "Document not found",
      });
    }

    res.status(200).json({
      success: true,
      data: document,
      message: "Summary updated successfully",
    });
  } catch (error) {
    console.error("Error updating summary:", error);
    res.status(500).json({
      success: false,
      error: "Failed to update summary",
    });
  }
};
